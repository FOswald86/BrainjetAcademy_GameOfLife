type: edu
custom_name: stage5
files:
- name: src/life/Main.java
  visible: true
  text: |
    package life;

    public class Main {
        public static void main(String[] args) {
            System.out.println("Hello, world!");
        }
    }
  learner_created: false
- name: test/GameOfLifeTest.java
  visible: false
  text: |
    import life.GameOfLife;
    import org.assertj.swing.fixture.JButtonFixture;
    import org.assertj.swing.fixture.JLabelFixture;
    import org.assertj.swing.fixture.JToggleButtonFixture;
    import org.hyperskill.hstest.common.Utils;
    import org.hyperskill.hstest.dynamic.DynamicTest;
    import org.hyperskill.hstest.exception.outcomes.WrongAnswer;
    import org.hyperskill.hstest.stage.SwingTest;
    import org.hyperskill.hstest.testcase.CheckResult;
    import org.hyperskill.hstest.testing.swing.SwingComponent;

    import java.util.regex.Matcher;
    import java.util.regex.Pattern;

    import static org.hyperskill.hstest.testcase.CheckResult.correct;
    import static org.hyperskill.hstest.testcase.CheckResult.wrong;

    public class GameOfLifeTest extends SwingTest {

        public GameOfLifeTest() {
            super(new GameOfLife());
        }

        @SwingComponent(name = "GenerationLabel")
        JLabelFixture generationLabel;

        @SwingComponent(name = "AliveLabel")
        JLabelFixture aliveLabel;

        @SwingComponent(name = "PlayToggleButton")
        JToggleButtonFixture playButton;

        @SwingComponent(name = "ResetButton")
        JButtonFixture resetButton;

        @DynamicTest(order = 1)
        CheckResult testWindow() {
            requireVisible(window);
            return correct();
        }

        @DynamicTest(order = 2)
        CheckResult testGenerationLabel() {
            requireEnabled(generationLabel);
            requireVisible(generationLabel);
            return correct();
        }

        @DynamicTest(order = 3)
        CheckResult testAliveLabel() {
            requireEnabled(aliveLabel);
            requireVisible(aliveLabel);
            return correct();
        }

        @DynamicTest(order = 4)
        CheckResult testForIntegerInLabels() {

            Pattern pattern = Pattern.compile("\\d+");
            Matcher matcher = pattern.matcher(generationLabel.text());

            if (!matcher.find()) {
                return wrong("The 'GenerationLabel' doesn't contain an integer number!");
            }

            matcher = pattern.matcher(aliveLabel.text());

            if (!matcher.find()) {
                return wrong("The 'AliveLabel' doesn't contain an integer number!");
            }

            return correct();
        }

        @DynamicTest(order = 5)
        CheckResult testPlayButton() {
            requireEnabled(playButton);
            requireVisible(playButton);
            playButton.click();
            playButton.click();
            return correct();
        }

        @DynamicTest(order = 6)
        CheckResult testResetButton() {
            requireEnabled(resetButton);
            requireVisible(resetButton);
            resetButton.click();
            return correct();
        }

        @DynamicTest(order = 7)
        CheckResult testButtonsActions() {

            playButton.uncheck();
            resetButton.click();

            int firstGenerationNumber = getNumberFromLabel(generationLabel);
            Utils.sleep(200);
            int secondGenerationNumber = getNumberFromLabel(generationLabel);

            if (firstGenerationNumber != secondGenerationNumber) {
                return wrong("When PlayToggleButton is not toggled the program shouldn't generate new generations! The number in GenerationLabel shouldn't change!");
            }

            resetButton.click();
            firstGenerationNumber = getNumberFromLabel(generationLabel);
            playButton.check();
            Utils.sleep(200);
            secondGenerationNumber = getNumberFromLabel(generationLabel);

            if (firstGenerationNumber == secondGenerationNumber) {
                return wrong("When PlayToggleButton is toggled the program should generate new generations! The number in GenerationLabel should change!\n" +
                        "Also make sure your program doesn't sleep more than 150 ms after each generation!");
            }

            return correct();
        }

        private static int getNumberFromLabel(JLabelFixture labelFixture) {
            Pattern pattern = Pattern.compile("\\d+");
            Matcher matcher = pattern.matcher(labelFixture.text());

            System.out.println(labelFixture.text());

            if (!matcher.find()) {
                throw new WrongAnswer("Can't find a number in the '" + labelFixture.text() + "'!");
            }

            return Integer.parseInt(matcher.group());
        }
    }
  learner_created: false
- name: src/life/Universe.java
  visible: true
  text: |
    package life;

    import java.util.Arrays;

    public class Universe {
        private char[][] currentState;

        public char[][] getCurrentState() {
            return currentState;
        }

        public void setCurrentState(char[][] currentState) {
            this.currentState = currentState;
        }

        public void showCurrentState(){
            Arrays.stream(this.currentState).forEachOrdered(System.out::println);
        }
    }
  learner_created: true
- name: src/life/GameOfLife.java
  visible: true
  text: |-
    package life;

    import javax.swing.*;
    import java.awt.*;

    public class GameOfLife extends JFrame {
        JLabel GenerationLabel;
        JLabel AliveLabel;
        Grid grid;
        int currentGeneration = 0;
        JToggleButton playToggleButton;
        JButton resetButton;
        boolean isPaused;
        boolean isReset;

        public GameOfLife() {
            super("Game of Life");

            setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
            //setSize(screenSize.width, screenSize.height);
            setSize(400, 400);
            setLocationRelativeTo(null);
            setLayout(new BoxLayout(getContentPane(), BoxLayout.Y_AXIS));

            playToggleButton = new JToggleButton();
            playToggleButton.setName("PlayToggleButton");
            playToggleButton.setText("Pause/Play");
            playToggleButton.addActionListener(actionEvent -> isPaused = !isPaused);
            add(playToggleButton);

            resetButton = new JButton();
            resetButton.setName("ResetButton");
            resetButton.setText("Reset");
            resetButton.addActionListener(actionEvent -> isReset = true);
            add(resetButton);

            GenerationLabel = new JLabel();
            GenerationLabel.setName("GenerationLabel");
            GenerationLabel.setText("Generation #" + getCurrentGeneration());


            AliveLabel = new JLabel();
            AliveLabel.setName("AliveLabel");
            AliveLabel.setText("Alive: 0");

            add(GenerationLabel);
            add(AliveLabel);

            grid = new Grid();
            add(grid);

            setVisible(true);
        }

        public int getCurrentGeneration() {
            return currentGeneration;
        }

        public void nextGeneration() {
            this.currentGeneration++;
        }

        public boolean isPaused() {
            return isPaused;
        }

        public boolean isReset() {
            return isReset;
        }

        public void reset(){
            this.currentGeneration = 0;
            this.isReset = false;
        }
    }
  learner_created: true
- name: src/life/Generation.java
  visible: true
  text: |+
    package life;

    import java.util.Objects;
    import java.util.Random;

    public class Generation {
        private Universe universe;
        private int n; // universe size
        private int s; // seed for random
        private int m; // number of generations
        private Random random;

        public Generation(Universe universe){
            this(universe, 20);
        }

        public Generation(Universe universe, int n) {
            this.universe = universe;
            this.n = n;
            this.random = new Random();
        }

        public Generation(Universe universe, int n, int s, int m) {
            this.universe = universe;
            this.n = n;
            this.s = s;
            this.m = m;
            this.random = new Random(s);
        }

        public char[][] generationZero() {
            char[][] universe = new char[this.n][this.n];
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    universe[i][j] = random.nextBoolean() ? 'O' : ' ';
                }
            }
            return universe;
        }

        public void nextGeneration() {
            //An alive cell survives if has two or three alive neighbors;
            //otherwise, it dies of boredom (<2) or overpopulation (>3)
            //A dead cell is reborn if it has exactly three alive neighbors
            char[][] currentGen = universe.getCurrentState();
            int len = currentGen.length;
            char[][] nextGen = new char[len][len];
            for (int row = 0; row < len; row++) {
                for (int col = 0; col < len; col++) {
                    int neighborCount = getNeighbourCount(currentGen, row, col);
                    // Check if cell alive
                    if (currentGen[row][col] == 'O') {
                        // Cell survives
                        if (neighborCount == 2 || neighborCount == 3) {
                            nextGen[row][col] = 'O';
                        } else {
                            // Cell dies
                            nextGen[row][col] = ' ';
                        }
                    }
                    // Check dead cell
                    if (currentGen[row][col] == ' ') {
                        if (neighborCount == 3) {
                            // Cell is reborn
                            nextGen[row][col] = 'O';
                        } else {
                            // Cell remains dead
                            nextGen[row][col] = ' ';
                        }
                    }
                }
            }
            universe.setCurrentState(nextGen);
        }

        private int getNeighbourCount(char[][] universe, int row, int col) {
            int count = 0;
            int size = universe.length;

            //Check N
            if (row == 0) { //Top row, check bottom row
                if (isAlive(universe, size - 1, col)) {
                    count++;
                }
            } else { //Any other point
                if (isAlive(universe, row - 1, col)) {
                    count++;
                }
            }

            //Check E
            if (col == (size - 1)) { //Right col, check left col
                if (isAlive(universe, row, 0)) {
                    count++;
                }
            } else { //Any other point
                if (isAlive(universe, row, col + 1)) {
                    count++;
                }
            }

            //Check S
            if (row == size - 1) { //Bottom row, check top row
                if (isAlive(universe, 0, col)) {
                    count++;
                }
            } else { //Any other point
                if (isAlive(universe, row + 1, col)) {
                    count++;
                }
            }

            //Check W
            if (col == 0) { //Left col, check right col
                if (isAlive(universe, row, size - 1)) {
                    count++;
                }
            } else { //Any other point
                if (isAlive(universe, row, col - 1)) {
                    count++;
                }
            }

            //Check NE
            if (row == 0 && (col == size - 1)) { //Top right corner, check bottom left corner
                if (isAlive(universe, size - 1, 0)) {
                    count++;
                }
            } else if (col == size - 1) { //Right col, check left col
                if (isAlive(universe, row - 1, 0)) {
                    count++;
                }
            } else if (row == 0) { //Top row, check bottom row
                if (isAlive(universe, size - 1, col + 1)) {
                    count++;
                }
            } else { //Any other point
                if (isAlive(universe, row - 1, col + 1)) {
                    count++;
                }
            }

            //Check SE
            if (row == size - 1 && col == size - 1) { //Bottom right corner, check top left corner
                if (isAlive(universe, 0, 0)) {
                    count++;
                }
            } else if (col == size - 1) { //Right col, check left col
                if (isAlive(universe, row + 1, 0)) {
                    count++;
                }
            } else if (row == size - 1) { //Bottom row, check top row
                if (isAlive(universe, 0, col + 1)) {
                    count++;
                }
            } else { //Any other point
                if (isAlive(universe, row + 1, col + 1)) {
                    count++;
                }
            }

            //Check SW
            if (row == size - 1 && col == 0) { //Bottom left corner, check top right corner
                if (isAlive(universe, 0, size - 1)) {
                    count++;
                }
            } else if (col == 0) { //Left col, check right col
                if (isAlive(universe, row + 1, size - 1)) {
                    count++;
                }
            } else if (row == size - 1) { //Bottom row, check top row
                if (isAlive(universe, 0, col - 1)) {
                    count++;
                }
            } else { //Any other point
                if (isAlive(universe, row + 1, col - 1)) {
                    count++;
                }
            }

            //Check NW
            if (row == 0 && col == 0) { //Top left corner, check bottom right corner
                if (isAlive(universe, size - 1, size - 1)) {
                    count++;
                }
            } else if (col == 0) { //Left col, check right col
                if (isAlive(universe, row - 1, size - 1)) {
                    count++;
                }
            } else if (row == 0) { //Top row, check bottom row
                if (isAlive(universe, size - 1, col - 1)) {
                    count++;
                }
            } else { //Any other point
                if (isAlive(universe, row - 1, col - 1)) {
                    count++;
                }
            }

            return count;
        }


        private static boolean isAlive(char[][] universe, int row, int col) {
            return Objects.equals(universe[row][col], 'O');
        }

        public int getAliveCount(char[][] universe){
            int count = 0;
            for (int i = 0; i < universe.length; i++) {
                for (int j = 0; j < universe.length; j++) {
                    if (isAlive(universe, i, j)) {
                        count++;
                    }
                }
            }
            return count;
        }
    }

  learner_created: true
- name: src/life/Grid.java
  visible: true
  text: |
    package life;

    import javax.swing.*;
    import java.awt.*;
    import java.util.ArrayList;

    public class Grid extends JPanel {

        private ArrayList<Point> cells;
        private int size = 20;

        public Grid() {
            cells = new ArrayList<>();
        }

        public Grid(int size) {
            cells = new ArrayList<>();
            this.size = size;
        }

        @Override
        protected void paintComponent(Graphics g) {
            super.paintComponent(g);

            // Draw rectangle around outside of grid
            g.drawRect(10, 10, size * 10, size * 10);

            // Draw column lines for grid
            for (int i = 10; i <= size * 10; i += 10) {
                g.drawLine(i, 10, i, size * 10 + 10);
            }

            // Draw row lines for grid
            for (int i = 10; i <= size * 10; i += 10) {
                g.drawLine(10, i, size * 10 + 10, i);
            }
            g.setColor(Color.BLACK);

            // Fill alive cells
            for (Point cell : cells) {
                int cellX = 10 + (cell.x * 10);
                int cellY = 10 + (cell.y * 10);

                g.setColor(Color.RED);
                g.fillRect(cellX, cellY, 10, 10);
            }

        }

        public void fillCell(int x, int y) {
            cells.add(new Point(x, y));
            repaint();
        }

        public void removeCell(int x, int y) {
            cells.remove(new Point(x, y));
            repaint();
        }
    }
  learner_created: true
- name: src/life/Controller.java
  visible: true
  text: |
    package life;

    import java.io.IOException;

    public class Controller {

        public static void clearScreen() {
            try {
                if (System.getProperty("os.name").contains("Windows"))
                    new ProcessBuilder("cmd", "/c", "cls").inheritIO().start().waitFor();
                else
                    Runtime.getRuntime().exec("clear");
            } catch (IOException | InterruptedException e) {
                System.out.println(e);
            }
        }
    }
  learner_created: true
feedback_link: https://hyperskill.org/projects/54/stages/299/implement#comment
status: Failed
feedback:
  message: |-
    Wrong answer in test #7

    When PlayToggleButton is toggled the program should generate new generations! The number in GenerationLabel should change!
    Also make sure your program doesn&#39;t sleep more than 150 ms after each generation!

    Please find below the output of your program during this failed test.

    ---

    Generation #0
    Generation #0
    Generation #0
    Generation #0
  time: Sat, 09 Oct 2021 17:07:14 UTC
record: -1
